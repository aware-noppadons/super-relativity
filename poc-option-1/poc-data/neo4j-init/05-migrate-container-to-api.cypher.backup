// Migration: Replace Container with API and Create Table nodes
// Part 1: Container → API migration
// Part 2: Create Table nodes and link to DataObject

// ============================================================================
// PART 1: Migrate Container to API
// ============================================================================

// Step 1: Create API nodes from Containers that expose APIs
// (excluding pure storage containers like Database and Object Storage)

MATCH (c:Container)
WHERE c.type IN ['API Gateway', 'Microservice', 'Single-Page Application', 'Backend Service']
CREATE (api:API {
  id: replace(c.id, 'CONT-', 'API-'),
  name: c.name,
  type: c.type,
  technology: c.technology,
  description: c.description,
  responsibilities: c.responsibilities,
  protocol: c.communicationProtocol,
  port: c.port,
  deployment: c.deployment,
  scaling: c.scaling,
  source: c.source,
  migrated: true,
  migratedFrom: 'Container',
  migrationDate: datetime()
})
WITH c, api
// Copy Container label temporarily for relationship migration
SET api:Container_Temp
RETURN c.id, c.name, api.id, api.name;

// Step 2: Migrate relationships from Container to API

// CONTAINS relationships (Application/Component → API)
MATCH (parent)-[old:CONTAINS]->(c:Container_Temp)
CREATE (parent)-[:CONTAINS {
  level: old.level,
  source: old.source
}]->(c);

// COMMUNICATES_WITH relationships (API ↔ API)
MATCH (c1:Container_Temp)-[old:COMMUNICATES_WITH]->(c2:Container_Temp)
CREATE (c1)-[:CALLS {
  protocol: old.protocol,
  synchronous: old.synchronous,
  description: old.description,
  source: old.source
}]->(c2);

// DEPLOYED_ON relationships (API → Server)
MATCH (c:Container_Temp)-[old:DEPLOYED_ON]->(s:Server)
CREATE (c)-[:DEPLOYED_ON {
  environment: old.environment,
  replicas: old.replicas,
  description: old.description,
  source: old.source
}]->(s);

// MODIFY relationships (Change → API)
MATCH (change)-[old:MODIFY]->(c:Container_Temp)
CREATE (change)-[:MODIFY {
  action: old.action,
  syncedAt: old.syncedAt,
  description: old.description,
  impact: old.impact,
  downtime: old.downtime,
  migrated: old.migrated,
  migrationDate: old.migrationDate
}]->(c);

// Step 3: Remove Container_Temp label, leaving only API label
MATCH (api:Container_Temp)
REMOVE api:Container_Temp;

// Step 4: Handle storage Containers differently - convert to storage infrastructure
// Database and Object Storage become part of infrastructure, not APIs

MATCH (c:Container)
WHERE c.type IN ['Database', 'Object Storage']
SET c:StorageInfrastructure
REMOVE c:Container;

// ============================================================================
// PART 2: Create Table nodes for physical storage
// ============================================================================

// Create Table nodes from DataObject information
// Tables represent physical database tables that compose logical DataObjects

MATCH (d:DataObject)
WHERE d.type = 'Database Table'
CREATE (t:Table {
  id: replace(d.id, 'DATA-', 'TBL-'),
  name: d.name,
  schema: d.schema,
  database: d.database,
  columns: d.columns,
  recordCount: d.recordCount,
  growthRate: d.growthRate,
  indexes: [],
  primaryKey: 'id',
  source: 'migration',
  createdDate: datetime()
})
WITH d, t
CREATE (d)-[:COMPOSED_OF {
  mappingType: 'one-to-one',
  description: 'DataObject directly maps to single table',
  source: 'migration'
}]->(t)
RETURN d.name, t.name;

// For DataObjects that are not single tables, create sample decomposition
// Example: CustomerTable might be composed of customer_base + customer_addresses

MATCH (d:DataObject {id: 'DATA-789'})
CREATE (t1:Table {
  id: 'TBL-789-1',
  name: 'customer_base',
  schema: 'public',
  database: 'customer_db',
  columns: ['id', 'name', 'email', 'phone', 'created_at', 'updated_at'],
  recordCount: 1500000,
  primaryKey: 'id',
  source: 'migration'
}),
(t2:Table {
  id: 'TBL-789-2',
  name: 'customer_addresses',
  schema: 'public',
  database: 'customer_db',
  columns: ['id', 'customer_id', 'address', 'city', 'state', 'zip'],
  recordCount: 2000000,
  primaryKey: 'id',
  foreignKeys: ['customer_id'],
  source: 'migration'
})
WITH d, t1, t2
CREATE (d)-[:COMPOSED_OF {
  mappingType: 'one-to-many',
  description: 'Customer data decomposed across base and address tables'
}]->(t1),
(d)-[:COMPOSED_OF {
  mappingType: 'one-to-many',
  description: 'Customer addresses stored separately'
}]->(t2);

// Link Tables to StorageInfrastructure (physical location)
MATCH (t:Table {database: 'customer_db'}), (si:StorageInfrastructure {name: 'PostgreSQL Database'})
CREATE (t)-[:STORED_IN {
  description: 'Physical storage location'
}]->(si);

MATCH (t:Table {database: 'application_db'}), (si:StorageInfrastructure {name: 'PostgreSQL Database'})
CREATE (t)-[:STORED_IN {
  description: 'Physical storage location'
}]->(si);

// ============================================================================
// Verification Queries
// ============================================================================

// Count migration results
MATCH (api:API)
WITH count(api) as apiCount
MATCH (si:StorageInfrastructure)
WITH apiCount, count(si) as storageCount
MATCH (t:Table)
RETURN
  apiCount as totalAPIs,
  storageCount as totalStorageInfra,
  count(t) as totalTables;

// Show API relationships
MATCH (api:API)-[r]-()
RETURN type(r) as relType, count(*) as count
ORDER BY count DESC;

// Show DataObject → Table composition
MATCH (d:DataObject)-[r:COMPOSED_OF]->(t:Table)
RETURN d.name, r.mappingType, collect(t.name) as tables;
